---
title: "Software Design - Presentation"
date: 2024-01-20 21:05:00
draft: true

tags: ["Software Design"]
---




https://developer.apple.com/tutorials/swiftui-concepts/driving-changes-in-your-ui-with-state-and-bindings
https://blog.devgenius.io/swiftui-state-vs-binding-727262600884
https://ivanfan.site/2020/07/17/uiwidget/




## Ref
- [ゲーム開発 に所謂なアプリケーション設計パターンをおいそれと適用するのは難しい](https://hadashia.hatenablog.com/entry/2020/12/22/162525)







即使在遊戲中，“領域邏輯和表現的分離”也應該是一個常見的做法。如果抽象數據和視圖之間的邊界不是鬆散耦合的，那麼情況就會變得很麻煩。因為“角色數據”與“想要應用於屏幕的對象”的關係並非一對一，而且存在著想要參考數據但尚未顯示在屏幕上的情況，這種情況非常常見。簡而言之，MVC所說的“模型”並不是指所有轉換的狀態，而是指“應用程序特定狀態”。

然而，在遊戲中，套用某種強大的框架或基礎設施的設計模式往往只會增加麻煩。

首先，建立一個MVP的結構，

完全區分M和V的領域。
在M方面，可以使用DDD風格的分層架構，或者根據需要進行責任劃分。
V組件本身應該像黑盒子一樣隱藏，例如，可以隱藏父子關係或過於細緻的控制。（就像馬里奧的gif一樣）
Presenter/Controller用於連接這些領域。
只要按照這些基礎進行項目分類，根據項目的需要進行調整就足夠了。
將抽象層次重疊多次的分層（乾淨）架構的想法，僅適用於抽象數據交換部分，

而MVC派生的“領域和表現的分離”則應該適用於整個系統。

對於外部來說，將UI = f（state）的思想隱藏起來，以隱藏視圖的狀態轉換，也是相當不錯的。

然而，自動對視圖進行映射的想法可能會降低生產力、可維護性和靈活性。

以上就是我的看法。








分離「領域邏輯和演示」也是一個普遍且值得做的事情。



將 View 定義為「View = f(state)」的純函數


這種模式被稱為「函數式UI」（Functional UI）或「狀態驅動UI」（State-Driven UI）。這種模式的概念是將 UI 定義為一個純函數，其輸入僅依賴於應用的狀態，而不包含任何隱含的狀態。這樣的設計使得 UI 的渲染變得非常簡潔且可預測，並且易於測試和維護。




畫面轉換必須是「共通功能」
如果在發布時要建立100個以上的畫面，一個一個地建立將永遠無法結束
1.多人同時開發
2.直接轉換
3.畫面製作的共通化
建議每個畫面都建立一個Prefab，並且讓多人同時開發多個畫面

直接轉換指的是，可以直接從任何畫面轉換到任何其他畫面。
更具體地說，例如任務畫面不需要經過主畫面才能轉換，這樣的限制是不被允許的。
換句話說，任務畫面可以從主畫面或強化畫面任意一個地方轉換。

在開發中，最耗時的事情是「猶豫不決」。
建議制定以下規則，並可進行擴展，讓所有畫面都具備以下功能：

畫面顯示前的處理
畫面顯示
畫面隱藏
畫面隱藏後的處理



-----
抽象數據和視圖的邊界必須疏離耦合，否則將會遇到嚴重問題。
由於「角色數據」與「要應用於屏幕上的對象」之間的關係不是一對一的，
而且還有一些情況是尚未顯示在屏幕上，但需要參考數據，這就是這種情況的原因。

總之，MVC所說的「Model」不是所有狀態轉換，而是「應用程序特定狀態」。

然而，在遊戲中使用強大的框架和基於預設的設計模式只會變成一種麻煩。

首先，構建MVP的結構，使M和V的世界完全分開。M部分可以創建基於DDD分層體系結構等的責任分配。 V組件本身可以隱藏細節並形成黑盒子，例如父子關係或過於細節的控制，因為這些內容可以從外部隱藏起來。

Presenter/Controller則連接這些世界。只要以此為基礎，在適當的項目中改變分類方式就足夠了。

多層抽象層(乾淨的)架構的思想只需應用於抽象數據交換部分即可。

派生自MVC的「領域和演示的分離」可應用於整個系統。

外部看來，UI = f(state)的觀念隱藏了視圖狀態轉換，這也是非常有用的。

但是，自動映射到視圖的方法可能不太靈活，並且可能會影響生產力和可維護性。

以上是個人的看法。




View = f(state)

在理解 View 是怎麼變化的時候，能夠先決定並先控制好 state，render 過程中也不會改變 state，剩下的事情就輕鬆簡單了

畢竟，視圖只是核心模型的投影，而這只是為了描述應用程序的核心狀態。它之外的任何東西都應該由視圖模型或視圖層處理



畫面設計
手機遊戲的畫面設計要求
・我想批量生產具有各種功能的螢幕。
主螢幕、卡片螢幕、任務螢幕、扭蛋螢幕、活動螢幕等。
我想支援螢幕之間的頻繁轉換
我想返回到上一個螢幕或在螢幕之間傳遞訊息。
需要一個能夠在螢幕之間平滑過渡並實現高效批量生產的平台。


階層關係
Scene - Window - Screen


Scene
- OnInitialize
- OnOpenIn
- OnCloseIn
- OnOpenOut
- OnCloseOut
- Close

Window
- Open
- Switch

Screen
- Close

樹狀結構
要做到疊加是相對方便
屏幕之間的頻繁轉換，以及在這些轉換期間需要交換的資訊 -> 通過按住和管理 >螢幕實現
需要更深入地過渡到層次結構 -> 通過擴展整個螢幕而不是單個螢幕來實現的

角色資訊頁 -> 角色強化頁


分成 
呈現 與 容器


情境 Extra1
AppScene -> CharaWindow -> CharaInfoScreen

AppScene -> CharaWindow -> CharaInfoScreen
         -> StoreWindow -> StuffInfoScreen
                        -> StuffBuyScreen






